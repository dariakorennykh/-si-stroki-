# -si-stroki-
Си-строки
В прошлом уроке мы разобрали динамические String-строки в реализации Arduino, а сейчас настало время стандартных статических строк языка C/C++. Такая строка представляет собой массив символов типа char (char array) и для неё работает такой же синтаксис, как и для остальных массивов (урок про массивы). Конец строки определяется нулевым символом \0 (или целым число 0), за это такой тип строк называют null-terminated string: ноль на конце позволяет программе определять конец строки и её длину. Также это стандартные строки языка Си и поэтому называются cstring.
Текст в кавычках
Любой написанный в двойных кавычках текст "some text":

Является строковой константой - string constant
Имеет тип данных const char* - то есть указывает на свой первый символ в памяти
Хранится и в программной, и в оперативной памяти микроконтроллера
Компилятор автоматически добавляет нулевой символ в конец строки '\0' - то есть реальный размер строки всегда на 1 символ больше
Оптимизируется компилятором - об этом ниже
Оптимизация компилятором
Компилятор оптимизирует строковые константы, но не во всех случаях. Если создать несколько строк как массивы (которые можно изменять) и присвоить им одинаковые строки, то они займут место в памяти как разные строки, т.е. столько, сколько в них суммарно символов:

Сложение
Строковые константы можно складывать через пробелы:

Перенос строк (в программе)
Длинную строку можно переносить для удобства чтения и редактирования программы. Есть два способа:

Первый способ - работает как сложение строк в предыдущей главе. Каждая строка в своих кавычках пишется с новой строки

Перенос строк (текст)
Для человека текст с новой строки - это текст с новой строки. Чтобы перенести текст на новую строку, мы нажимаем на клавишу Enter на клавиатуре. В то же время текст в текстовых файлах не хранится в разных "строках", он лежит в памяти одной длинной строкой. Когда мы открываем файл, компьютер читает текст и ищет в нём специальные невидимые символы, которые называются управляющими символами. Одним из таких символов является перенос строки - \n, именно его добавляет клавиша Enter. Чтобы компьютер при выводе строки перенёс её - нужно добавить этот символ в текст. В программе мы будем видеть этот символ, а вот в результирующем тексте он автоматически превратится в перенос строки. Примеры (без переноса в программе и с переносом двумя способами):

Массив символов
Объявление как массив
Основное отличие таких строк от String-строк: это обычный массив, размер которого известен заранее и не меняется в процессе работы. Можно объявить строку как массив и посимвольно задать текст:

char str[] = {'h', 'e', 'l', 'l', 'o', 0};  // с нулевым символом на конце
Такой вариант записи не очень удобный, поэтому строки в C/C++ можно задавать просто текстом в двойных кавычках - компилятор сам посчитает размер массива:

char str[] = "hello";
Полученный выше массив содержит 6 символов: 5 на слово hello и 1 на завершающий символ. Текст в данном массиве можно изменять в процессе работы программы, потому что с точки зрения программы мы создали обычный массив и заполнили его буквами. Изменим первую букву на прописную: str[0] = 'H';. Выведем в монитор порта:

Serial.println(str);
Serial умеет работать с такими данными и с радостью их выведет.

Объявление как указатель
Также строку можно объявить как указатель на const char* - то есть сам текст в кавычках хранится где то в программе, а мы получаем на него "ссылку":

const char* str = "hello";
Текст в такой строке менять уже нельзя, но можно использовать дальше в программе для сложения или вывода:

Serial.println(str);
Примечание: можно объявить и как char* str = "hello"; и пользоваться дальше точно так же как массивом, но компилятор выдаст предупреждение что строковая константа (текст в кавычках) приравнивается к неконстантному типу.

Массив строк
Можно создать один массив с несколькими строками и обращаться к ним по индексу, фактически это будет двухмерный массив (массив массивов). Выглядит следующим образом:

// объявляем массив строк
const char* names[]  = {
  "Period",   // 0
  "Work",     // 1
  "Stop",     // 2
};
// выводим третий элемент
Serial.println(names[2]); // выведет Stop
Таким образом удобно паковать строки для создания текстовых меню и прочего. Единственный большой минус - весь этот текст висит в оперативной памяти мёртвым грузом. Можно сохранить его во Flash - программной памяти (PROGMEM), об этом читайте в отдельном уроке.

Точно также можно создать массив массив пустых строк для дальнейшей работы:

char arr[к-во строк][макс. длина];
По сути это будет двухмерный массив. Копирование другой строки в массив может выглядеть так: strcpy(arr[0], str);. Об этом читайте ниже.

Длина строки
Для определения длины текста можно использовать оператор strlen(), который возвращает количество символов в строке. Сравним его работу с оператором sizeof():

char str[100] = "World";
sizeof(str);  // вернёт 100
strlen(str);  // вернёт 5
Здесь оператор sizeof() вернул количество байт, занимаемое массивом. Массив я специально объявил с размером бОльшим, чем содержащийся в нём текст. А вот оператор strlen() посчитал и вернул количество символов, которые идут с начала массива и до нулевого символа в конце текста без его учёта. А вот такой будет результат при инициализации без указания размера массива:

char text[] = "Hello";
strlen(text);   // вернёт 5 ("читаемых" символов)
sizeof(text);   // вернёт 6 (байт)
Отличия от String
В отличие от String-строк, Си-строки:

char str[] = "hello";
char str2[] = "world";
str += str2;      // НЕЛЬЗЯ складывать 
str = "text";     // НЕЛЬЗЯ присваивать после инициализации 
if (str == str2); // НЕЛЬЗЯ сравнивать
Для этого существуют специальные функции, о которых мы поговорим ниже.

Оптимизация памяти
Как я писал выше - "текст в кавычках" хранится и в памяти программы, и в оперативной памяти, то есть после запуска микроконтроллера строка загружается в оперативную память, и уже там мы имеем к ней доступ. Как правило, объём программной памяти микроконтроллера в несколько раз больше, чем оперативной. Есть несколько возможностей хранения строк только в программной памяти, об этом очень подробно поговорим в уроке про PROGMEM.

Инструменты для Си-строк
Массивы символов не так просты, как кажутся: их возможности сильно расширяет стандартная библиотека cstring. Использование всех доступных фишек по работе с массивами символов позволяет полностью избавить свой код от тяжёлых String-строк и сделать его легче, быстрее и оптимальнее. Подробно обо всех инструментах можно почитать в официальной документации. Очень интересный пример с манипуляцией этими инструментами можно посмотреть здесь. А мы вкратце рассмотрим самые полезные.

Конвертирование
Есть готовые функции, позволяющие конвертировать различные типы данных в строки:

itoa(int_data, str, base) - записывает переменную типа int int_data в строку str с базисом* base.
utoa(uint_data, str, base) - записывает переменную типа unsigned int uint_data в строку str с базисом* base.
ltoa (long_data, str, base) - записывает переменную типа long long_data в строку str с базисом* base.
ultoa (unsigned_long_data, str, base) - записывает переменную типа unsigned long unsigned_long_data в строку str с базисом* base.
dtostrf(float_data, width, dec, str) - записывает переменную типа float float_data в строку str с количеством символов width и знаков после запятой dec.
* Примечание: base - основание системы счисления, тут всё как при выводе в Serial:

DEC - десятичная
BIN - двоичная
OCT - восьмеричная
HEX - шестнадцатеричная
float x = 12.123;
char str[10] = "";
dtostrf(x, 4, 2, str);
// тут str == "12.12"
int y = 123;
itoa(y, str, DEC);
// тут str == "123"
И наоборот, можно преобразовывать строки в численные данные, функция вернёт результат:

atoi(str) - преобразование str в int
atol(str) - преобразование str в long
atof(str) - преобразование str в float
float x;
char str[10] = "12.345";
x = atof(str);
// тут x == "12.345"
Внимание! Функции конвертирования, работающие с типом float, являются очень тяжёлыми: их "подключение" занимает ~2 кБ Flash памяти!! Максимально избегайте их применения в крупном проекте. Для преобразования можно сделать свою функцию, практически готовые варианты для всех типов данных можно найти в стандартной ардуиновской Print.cpp (ссылка на файл на гитхабе Arduino).
Работа с байтовым буфером
Очень часто в реальных задачах встречается ситуация, когда текстовые данные приходят в виде массива byte: по какому-нибудь каналу связи (MQTT, UDP, Bluetooth...), при чтении из файлов и так далее. Например приём по MQTT во многих библиотеках выглядит так:

void callback(byte* payload, uint16_t len) {
}
Пришёл поток байтов известной длины. Что с ними делать, если это текст и нам в программе он нужен как строка? Во многих примерах в Интернете предлагают преобразовать данные в String, просто как String s = (char*)payload. Делать так категорически нельзя, если переданный текст не оканчивается нулевым символом, а в большинстве случаев это как раз так. Дело в том, что свободная оперативная память во время работы микроконтроллера содержит не нули, а фактически случайные значения, оставшиеся от выгруженных переменных в разных местах программы. И если у нас приходит массив, который не оканчивается нулём, то в памяти после него тоже не обязан быть ноль, и при преобразовании в строку пойдёт вся память по порядку, пока не встретится ноль. 
